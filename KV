param(
    [Parameter(Mandatory=$true)][string]$adh_group,             # e.g., ADHCSM (custodian suffix in sub name)
    [Parameter(Mandatory=$true)][ValidateSet('prd','nonprd')][string]$adh_subscription_type,
    [string]$FilePath,                                          # resource_sanitychecks.xlx (or .xlsx/.xls)
    [bool]$IncludeSecretValues = $true
)

# ---------------- Modules ----------------
if (-not (Get-Module -ListAvailable -Name Az)) {
    Install-Module -Name Az -Force -AllowClobber -Scope CurrentUser -Confirm:$false
}
Import-Module Az -ErrorAction Stop

if (-not (Get-Module -ListAvailable -Name ImportExcel)) {
    Install-Module -Name ImportExcel -Force -Scope CurrentUser -Confirm:$false
}
Import-Module ImportExcel -ErrorAction Stop

# ---------------- Inputs & Environment ----------------
# SPN creds are provided from ADO Variable Groups via env vars
#   modernization_terraform_subscription_details
#   test_modernization_terraform_subscription_details
#   modernization_tfstate_backend_details
$clientId     = $env:client_id
$clientSecret = $env:client_secret

if ([string]::IsNullOrWhiteSpace($clientId) -or [string]::IsNullOrWhiteSpace($clientSecret)) {
    throw "Missing Service Principal credentials (client_id / client_secret) from variable groups."
}

# Base folder for IO
$BasePath = Join-Path $env:System_DefaultWorkingDirectory 'Modernization_Terraform/sanitychecks'
if (-not (Test-Path $BasePath)) { throw "Base path not found: $BasePath" }

# Resolve workbook path:
if (-not $FilePath) { $FilePath = Join-Path $BasePath 'resource_sanitychecks.xlx' }
function Resolve-Workbook([string]$p) {
    if (Test-Path -LiteralPath $p) { return $p }
    $alt = [IO.Path]::ChangeExtension($p,'xlsx'); if (Test-Path -LiteralPath $alt) { return $alt }
    $alt = [IO.Path]::ChangeExtension($p,'xls');  if (Test-Path -LiteralPath $alt) { return $alt }
    throw "Workbook not found. Tried: $p / $( [IO.Path]::ChangeExtension($p,'xlsx') ) / $( [IO.Path]::ChangeExtension($p,'xls') )"
}
$ExcelPath = Resolve-Workbook -p $FilePath

# ---------------- Read KV Secrets list ----------------
$WorksheetName    = 'KVSecrets'
$SecretColumnName = 'SECRET NAME'
$data = Import-Excel -Path $ExcelPath -WorksheetName $WorksheetName -ErrorAction Stop
if (-not ($data | Get-Member -Name $SecretColumnName -MemberType NoteProperty)) {
    throw "Column '$SecretColumnName' not found in sheet '$WorksheetName'."
}
$SecretNames = $data.$SecretColumnName |
    Where-Object { $_ -and $_.ToString().Trim() } |
    ForEach-Object { $_.ToString().Trim() } |
    Sort-Object -Unique
if (-not $SecretNames) { throw "No secret names found in '$SecretColumnName'." }

# ---------------- Auth (Tenant optional) ----------------
$spCred = New-Object System.Management.Automation.PSCredential ($clientId, (ConvertTo-SecureString $clientSecret -AsPlainText -Force))

# First try without tenant (your ask). If it fails and TENANT is provided, retry with it.
try {
    Connect-AzAccount -ServicePrincipal -Credential $spCred -ErrorAction Stop | Out-Null
} catch {
    if ($env:tenant_id) {
        Write-Warning "Retrying login using provided tenant_id..."
        Connect-AzAccount -ServicePrincipal -Tenant $env:tenant_id -Credential $spCred -ErrorAction Stop | Out-Null
    } else {
        throw "Azure login failed and tenant_id not provided. $_"
    }
}

# ---------------- Pick Subscriptions based on naming convention ----------------
# Examples expected:
#   dev_azure_20921_ADHCSM
#   prd_azure_20920_ADHCSM
$allSubs = Get-AzSubscription -ErrorAction Stop
$patternSuffix = "_$adh_group"             # e.g., _ADHCSM

if ($adh_subscription_type -eq 'nonprd') {
    # Only dev subscriptions (tst/stg are environments within dev sub, as per your note)
    $subs = $allSubs | Where-Object { $_.Name -like "dev_*$patternSuffix" }
} else {
    # prd subscriptions
    $subs = $allSubs | Where-Object { $_.Name -like "prd_*$patternSuffix" }
}

if (-not $subs) { throw "No subscriptions matched: type=$adh_subscription_type, adh_group=$adh_group, pattern=*_*$patternSuffix" }

# ---------------- Helper: render value ----------------
function Render-Value([string]$v, [bool]$include) {
    if ($include) { return $v }
    if ([string]::IsNullOrEmpty($v)) { return "" }
    if ($v.Length -le 6) { return "***masked***" }
    return "{0}{1}{2}" -f $v.Substring(0,2),'***masked***',$v.Substring($v.Length-2,2)
}

# ---------------- Scan subs & vaults ----------------
$results = New-Object System.Collections.Generic.List[object]

foreach ($sub in $subs) {
    Write-Host "`n=== Subscription: $($sub.Name) [$($sub.Id)] ==="
    Set-AzContext -SubscriptionId $sub.Id -ErrorAction Stop | Out-Null

    $vaults = @()
    try {
        $vaults = Get-AzKeyVault -ErrorAction Stop
    } catch {
        Write-Warning "  Could not list Key Vaults: $($_.Exception.Message)"
        $vaults = @()
    }

    if (-not $vaults -or $vaults.Count -eq 0) {
        # KeyVaults missing in this subscription â†’ produce rows per secret with reason
        foreach ($secName in $SecretNames) {
            $results.Add([pscustomobject]@{
                Custodian        = $adh_group
                SubscriptionName = $sub.Name
                SubscriptionId   = $sub.Id
                VaultName        = "N/A (no key vaults)"
                SecretName       = $secName
                Exists           = "No"
                Value            = ""
                Version          = ""
                ContentType      = ""
                UpdatedOn        = ""
                MissingReason    = "No Key Vaults in subscription"
            })
        }
        continue
    }

    foreach ($kv in $vaults) {
        Write-Host "  -> Vault: $($kv.VaultName)"
        foreach ($secName in $SecretNames) {
            try {
                $sec = Get-AzKeyVaultSecret -VaultName $kv.VaultName -Name $secName -ErrorAction Stop
                $results.Add([pscustomobject]@{
                    Custodian        = $adh_group
                    SubscriptionName = $sub.Name
                    SubscriptionId   = $sub.Id
                    VaultName        = $kv.VaultName
                    SecretName       = $secName
                    Exists           = "Yes"
                    Value            = (Render-Value $sec.SecretValueText $IncludeSecretValues)
                    Version          = $sec.Version
                    ContentType      = $sec.ContentType
                    UpdatedOn        = $sec.Updated
                    MissingReason    = ""
                })
            } catch {
                $results.Add([pscustomobject]@{
                    Custodian        = $adh_group
                    SubscriptionName = $sub.Name
                    SubscriptionId   = $sub.Id
                    VaultName        = $kv.VaultName
                    SecretName       = $secName
                    Exists           = "No"
                    Value            = ""
                    Version          = ""
                    ContentType      = ""
                    UpdatedOn        = ""
                    MissingReason    = "Secret not found"
                })
            }
        }
    }
}

# ---------------- Output CSV (in same folder) ----------------
$outDir  = Join-Path $BasePath 'kv-scan'
if (-not (Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir | Out-Null }
$ts      = (Get-Date).ToString('yyyyMMdd_HHmmss')
$outCsv  = Join-Path $outDir "$adh_group-KeyVault-Secret-Check-$ts.csv"

$results |
  Sort-Object SubscriptionName, VaultName, SecretName |
  Export-Csv -Path $outCsv -NoTypeInformation -Encoding UTF8

Write-Host "Scan complete. CSV: $outCsv"
