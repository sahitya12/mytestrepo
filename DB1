Task 1 — PowerShell (resolve subscription ID with new key)

Display name: Resolve subscription ID
Script Type: Inline

# Inputs
$adhGroup   = "$(adh_group)"
$adhSubType = "$(adh_subscription_type)"   # prd | nonprd

if ([string]::IsNullOrWhiteSpace($adhGroup) -or [string]::IsNullOrWhiteSpace($adhSubType)) {
  throw "adh_group or adh_subscription_type is empty."
}

# New naming: <adh_group>_<adh_subscription_type>_subscription_id
$key = "{0}_{1}_subscription_id" -f $adhGroup, $adhSubType
Write-Host "Looking up variable key: $key (from linked variable groups)"

# Variable groups expose vars as environment variables
$subId = (Get-Item -Path "Env:$key" -ErrorAction SilentlyContinue).Value
if (-not $subId) {
  throw "No subscription ID found for '$key'. Check your variable groups."
}

Write-Host "Resolved subscription: $subId"
Write-Host "##vso[task.setvariable variable=TargetSubId]$subId"


Ensure both variable groups are linked to the stage:

moderanization_terraform_subscription_details

test_moderanization_terraform_subscription_details
And they contain keys like FI_prd_subscription_id, FI_nonprd_subscription_id, etc.

Task 2 — Azure CLI (PowerShell Core) — unchanged logic

Deletes Serverless Starter Warehouse (fallback to Starter Warehouse) in all applicable workspaces:

If adh_subscription_type=prd → checks ADH_<adh_group>_prd

If adh_subscription_type=nonprd → checks ADH_<adh_group>_{dev,tst,stg} and deletes in whichever exist

Display name: Delete Databricks Serverless Starter Warehouse(s)
Azure subscription: your fixed service connection
Script Type: PowerShell Core

# Inputs
$adhGroup    = "$(adh_group)"
$adhSubType  = "$(adh_subscription_type)"   # prd | nonprd
$targetSub   = "$(TargetSubId)"

if ([string]::IsNullOrWhiteSpace($adhGroup) -or [string]::IsNullOrWhiteSpace($adhSubType)) {
  throw "adh_group or adh_subscription_type is empty."
}
if ([string]::IsNullOrWhiteSpace($targetSub)) {
  throw "TargetSubId is empty (Task 1 must run first)."
}

# Environments to check
$envs = if ($adhSubType -eq "prd") { @("prd") } else { @("dev","tst","stg") }
Write-Host "Subscription type: $adhSubType; Environments to check: $($envs -join ', ')"

# Switch to the resolved subscription
az account set --subscription $targetSub

# AAD access token for Azure Databricks control plane
$token = az account get-access-token --resource 2ff814a6-3304-4ab8-85cb-cd0e6f879c1d --query accessToken -o tsv
if ([string]::IsNullOrWhiteSpace($token)) { throw "Failed to obtain AAD token for Databricks." }
$headers = @{ Authorization = "Bearer $token" }

foreach ($env in $envs) {
  $wsName = "ADH_{0}_{1}" -f $adhGroup, $env
  Write-Host "-----"
  Write-Host "Processing workspace: $wsName"

  # Find workspace
  $ws = az resource list --resource-type Microsoft.Databricks/workspaces --query "[?name=='$wsName'] | [0]" -o json | ConvertFrom-Json
  if (-not $ws) {
    Write-Host "Workspace '$wsName' not found in subscription $targetSub. Skipping."
    continue
  }

  $host = "https://$($ws.properties.workspaceUrl)"
  Write-Host "Workspace host: $host"

  # List warehouses
  $listUri = "$host/api/2.0/sql/warehouses"
  try {
    $resp = Invoke-RestMethod -Method GET -Uri $listUri -Headers $headers -ErrorAction Stop
  } catch {
    Write-Warning "Failed to list warehouses for $wsName: $($_.Exception.Message)"
    continue
  }

  # Prefer serverless name, fallback to classic
  $primaryName  = "Serverless Starter Warehouse"
  $fallbackName = "Starter Warehouse"

  $starter = $resp.warehouses | Where-Object { $_.name -eq $primaryName } | Select-Object -First 1
  if (-not $starter) {
    Write-Host "'$primaryName' not found in $wsName; checking '$fallbackName'."
    $starter = $resp.warehouses | Where-Object { $_.name -eq $fallbackName } | Select-Object -First 1
  }

  if (-not $starter) {
    Write-Host "No Serverless/Starter Warehouse found in $wsName. Skipping."
    continue
  }

  # Delete (idempotent; ignore 404)
  $delUri = "$host/api/2.0/sql/warehouses/$($starter.id)"
  Write-Host "Deleting warehouse '$($starter.name)' (id: $($starter.id)) in $wsName"
  try {
    Invoke-RestMethod -Method DELETE -Uri $delUri -Headers $headers -ErrorAction Stop | Out-Null
    Write-Host "Deleted '$($starter.name)' in $wsName."
  } catch {
    if ($_.Exception.Response -and $_.Exception.Response.StatusCode.value__ -eq 404) {
      Write-Host "'$($starter.name)' already deleted in $wsName (404)."
    } else {
      throw
    }
  }
}

Write-Host "-----"
Write-Host "Completed checks for environments: $($envs -join ', ')"

Quick checklist

Release variables:
