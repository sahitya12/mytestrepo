# ===== Inputs from Variable Group (SPN creds) =====
$clientId     = (Get-Item Env:backend_client_id     -ErrorAction SilentlyContinue).Value
$clientSecret = (Get-Item Env:backend_client_secret -ErrorAction SilentlyContinue).Value
$tenantId     = (Get-Item Env:tenant_id             -ErrorAction SilentlyContinue).Value
if ([string]::IsNullOrWhiteSpace($clientId) -or [string]::IsNullOrWhiteSpace($clientSecret) -or [string]::IsNullOrWhiteSpace($tenantId)) {
  throw "Missing backend_client_id / backend_client_secret / tenant_id (ensure the correct variable group is linked and LAST where both are linked)."
}

# ===== Inputs from Release variables =====
$adhGroup   = "$(adh_group)"
$adhSubType = "$(adh_subscription_type)"   # nonprd | prd
if ([string]::IsNullOrWhiteSpace($adhGroup) -or [string]::IsNullOrWhiteSpace($adhSubType)) { throw "adh_group or adh_subscription_type is empty." }

# ===== Login with SPN =====
Write-Host "Logging into Azure with service principal (tenant: $tenantId)..."
az logout | Out-Null
$null = az login --service-principal -u $clientId -p $clientSecret --tenant $tenantId
if ($LASTEXITCODE -ne 0) { throw "az login failed." }

# ===== Find subscription by NAME (prefix rule) =====
# nonprd -> dev_azure_<xxxx>_ADH<adh_group>
# prd    -> prd_azure_<xxxx>_ADH<adh_group>
$subs = az account list --all -o json | ConvertFrom-Json
if (-not $subs) { throw "No subscriptions visible to this SPN." }

$pattern = if ($adhSubType -ieq "prd") {
  ("(?i)^prd_azure_.+_ADH{0}$" -f [regex]::Escape($adhGroup))
} else {
  ("(?i)^dev_azure_.+_ADH{0}$" -f [regex]::Escape($adhGroup))
}

$matches = $subs | Where-Object { $_.name -and ($_.name -match $pattern) }
if (-not $matches -or $matches.Count -eq 0) {
  $names = ($subs | Select-Object -ExpandProperty name) -join ", "
  throw "No subscription matched pattern '$pattern'. Visible: $names"
}
if ($matches.Count -gt 1) {
  Write-Warning ("Multiple subscriptions match '{0}': {1}" -f $pattern, (($matches | Select-Object -ExpandProperty name) -join " | "))
}
$targetSub  = $matches[0].id
$targetName = $matches[0].name

Write-Host "Resolved subscription: $targetName ($targetSub)"
az account set --subscription $targetSub

# ===== Environments to PLAN =====
$envs = if ($adhSubType -ieq "prd") { @("prd") } else { @("dev","tst","stg") }
Write-Host "PLAN mode. Environments to check: $($envs -join ', ')"

# ===== Databricks AAD token =====
$token = az account get-access-token --resource 2ff814a6-3304-4ab8-85cb-cd0e6f879c1d --query accessToken -o tsv
if ([string]::IsNullOrWhiteSpace($token)) { throw "Failed to obtain AAD token for Databricks." }
$headers = @{ Authorization = "Bearer $token" }

# ===== Build plan =====
$plan = @()
foreach ($env in $envs) {
  $wsName = "ADH_{0}_{1}" -f $adhGroup, $env
  Write-Host "-----"
  Write-Host "Checking workspace: $wsName"

  $ws = az resource list --resource-type Microsoft.Databricks/workspaces --query "[?name=='$wsName'] | [0]" -o json | ConvertFrom-Json
  if (-not $ws) { $plan += [pscustomobject]@{workspace=$wsName; host=$null; action="skip"; reason="workspace not found"; warehouse=$null; id=$null}; Write-Host "Workspace not found. Skipping."; continue }

  $workspaceUrl = $ws.properties.workspaceUrl
  if ([string]::IsNullOrWhiteSpace($workspaceUrl) -and $ws.id) { $workspaceUrl = az resource show --ids $ws.id --query "properties.workspaceUrl" -o tsv }
  if ([string]::IsNullOrWhiteSpace($workspaceUrl) -and $ws.id) { $workspaceUrl = az resource show --ids $ws.id --query "properties.parameters.workspaceUrl.value" -o tsv }
  if ([string]::IsNullOrWhiteSpace($workspaceUrl)) { $plan += [pscustomobject]@{workspace=$wsName; host=$null; action="skip"; reason="no workspaceUrl"; warehouse=$null; id=$null}; Write-Warning "workspaceUrl missing. Skipping."; continue }

  $dbxHost = if ($workspaceUrl -match '^https?://') { $workspaceUrl } else { "https://$workspaceUrl" }
  $listUri = "$dbxHost/api/2.0/sql/warehouses"

  try { $resp = Invoke-RestMethod -Method GET -Uri $listUri -Headers $headers -ErrorAction Stop }
  catch { $plan += [pscustomobject]@{workspace=$wsName; host=$dbxHost; action="skip"; reason="list failed"; warehouse=$null; id=$null}; Write-Warning "List failed for ${wsName}: $($_.Exception.Message)"; continue }

  $primaryName="Serverless Starter Warehouse"; $fallbackName="Starter Warehouse"
  $starter = $resp.warehouses | Where-Object { $_.name -eq $primaryName } | Select-Object -First 1
  if (-not $starter) { $starter = $resp.warehouses | Where-Object { $_.name -eq $fallbackName } | Select-Object -First 1 }

  if ($starter) {
    Write-Host "WOULD DELETE: '$($starter.name)' (id: $($starter.id)) in ${wsName}"
    $plan += [pscustomobject]@{workspace=$wsName; host=$dbxHost; action="would-delete"; reason="found"; warehouse=$starter.name; id=$starter.id}
  } else {
    Write-Host "No Serverless/Starter warehouse in ${wsName}"
    $plan += [pscustomobject]@{workspace=$wsName; host=$dbxHost; action="noop"; reason="not found"; warehouse=$null; id=$null}
  }
}

Write-Host "-----`nPLAN SUMMARY"
$plan | Sort-Object workspace | Format-Table workspace, host, action, reason, warehouse, id -AutoSize | Out-String | Write-Host

# Optional: expose a flag (note: cross-stage use in Classic is limited)
$wouldDelete = [bool]($plan | Where-Object { $_.action -eq "would-delete" })
Write-Host "WouldDelete=$wouldDelete"
