owners = [
    for raw in coalesce(each.value.owners, []) : (
      # if raw looks like "/users/<guid>", strip the prefix and pass the GUID directly
      startswith(raw, "/users/")
      ? element(split(raw, "/"), 2)
      # otherwise treat as UPN and map via data.azuread_user.owners[raw].id
      : data.azuread_user.owners[raw].id
    )
    if (
      # allow "/users/<guid>" without lookup
      startswith(raw, "/users/")
      # or include only if the UPN was successfully resolved
      || contains(keys(data.azuread_user.owners), raw)
    )
  ]

variable "groups" {
  description = "Groups to create"
  type = list(object({
    name            = string                # Group display name
    desc            = string                # Group description
    active          = bool                  # Whether to create/manage this group
    owners          = optional(list(string), [])
    requestable     = optional(bool, false) # Placeholder, not directly supported on azuread_group
    groupmembership = string                # "Assigned" | "DynamicUser" | "DynamicDevice"
    membership_rule = optional(string, null)# Required if groupmembership != "Assigned"
    members         = optional(list(string), [])
  }))
}



locals.tf :

locals {
  # Filter out inactive groups
  active_groups = {
    for g in var.groups : g.name => g
    if g.active == true
  }

  # Gather unique owner emails
  owner_emails = toset(flatten([
    for g in var.groups : coalesce(g.owners, [])
  ]))
}



data.tf:

data "azuread_client_config" "current" {}

data "azuread_user" "owners" {
  for_each             = local.owner_emails
  user_principal_name  = each.key
}

main.tf :

resource "azuread_group" "example" {
  for_each         = local.active_groups
  display_name     = each.value.name
  description      = each.value.desc
  security_enabled = true
  mail_enabled     = false

  owners = [
    for email in coalesce(each.value.owners, []) :
    data.azuread_user.owners[email].id
    if contains(keys(data.azuread_user.owners), email)
  ]

  # Dynamic membership if requested
  dynamic "dynamic_membership" {
    for_each = (
      each.value.groupmembership == "Assigned"
      ? []
      : [1]
    )
    content {
      enabled = true
      rule    = each.value.membership_rule
    }
  }
}


groups = [
  {
    name            = "DevOps-Team"
    desc            = "DevOps Engineers"
    active          = true
    owners          = ["alice@contoso.com"]
    requestable     = false
    groupmembership = "Assigned"
    membership_rule = null
    members         = []
  },
  {
    name            = "Finance-Team"
    desc            = "Finance Department"
    active          = false   # will be skipped
    owners          = ["bob@contoso.com"]
    requestable     = false
    groupmembership = "Assigned"
    membership_rule = null
    members         = []
  }
]

